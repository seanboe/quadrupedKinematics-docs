{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Quadruped Kinematics Docs! Quadruped Kinematics is an Arduino-compatible C/C++ library that handles inverse kinematics, static movement, walking, and more! It is currently in development, however will allow you to easily control a quadruped by performing all necessary calculations to determine a robot's joint angles. Development Development is done privately and completed updates are pushed remotely. Contributions are welcome, however please contact Sean Boerhout first for up-to-date workings of the library. All technical explanations are recorded on Sean's blog .","title":"Home"},{"location":"#quadruped-kinematics-docs","text":"Quadruped Kinematics is an Arduino-compatible C/C++ library that handles inverse kinematics, static movement, walking, and more! It is currently in development, however will allow you to easily control a quadruped by performing all necessary calculations to determine a robot's joint angles.","title":"Quadruped Kinematics Docs!"},{"location":"#development","text":"Development is done privately and completed updates are pushed remotely. Contributions are welcome, however please contact Sean Boerhout first for up-to-date workings of the library. All technical explanations are recorded on Sean's blog .","title":"Development"},{"location":"Kinematics-library/","text":"Kinematics library Updated on July 22, 2021 Description The Kinematics class calculates leg joint angles based on a provided cartesian foot position of a desired foot position. An object should be created for each leg so that all legs can be positioned individually. Important things to note: Calculations assume that provided cartesian coordinates are relative to the quadruped's horizontal position If the quadruped is not horizontal i.e. tilted, you must take account for that and compute adjustments relative to it All units are in millimeters Negative Y-coordinates specify a position towards the quadruped This class only supports legs with 3 degrees of freedom. It is assumed that each leg has 3 motors to control each joint. Foot Coordinate Axis Leg Numbering Functions Kinematics() Kinematics :: Kinematics (); Constructor. Create an instance of a Kinematics class as such: Kinematics LegKinematics (); init() void Kinematics :: init ( LegID legID , int16_t inputX , int16_t inputY , int16_t inputZ , Motor legMotors []) legID - The leg that the Kinematics object is controlling. Should be of type LegID inputX - The initial (startup) X position that the foot should go to. inputY - The initial (startup) Y position that the foot should go to. inputZ - The initial (startup) Z position that the foot should go to. legMotors[] - An array of length 12 (3 motors per leg, 4 legs) whose variables are of struct type Motor . Note that inputX, inputY, and inputZ are integrated into the Quadruped and StepPlanner classes and serve as origin foot positions there. Enums LegID An enum to describe each leg. typedef enum { LEG_1 = 1 , LEG_2 , LEG_3 , LEG_4 } LegID ; Structs Motor A struct that holds variables describing motor parameters. typedef struct { uint8_t controlPin ; // Angle/calculation stuff int16_t angleDegrees ; int16_t previousDegrees ; // previous degrees since last call to updateDynamicPositions() int16_t dynamicDegrees ; // Calibration uint16_t calibOffset ; // This is an offset for calibration (to keep the motor accurate) uint16_t maxPos ; uint16_t minPos ; uint16_t applicationOffset ; // This is an offset for putting the calculated angles in contex. // It is likely that the zero positions of the motors isn't where // calculations assumes it to be, so you need an offset to make // sure that the angle is correct relative to the motor's zero. } Motor ;","title":"Kinematics Library"},{"location":"Kinematics-library/#kinematics-library","text":"Updated on July 22, 2021","title":"Kinematics library"},{"location":"Kinematics-library/#description","text":"The Kinematics class calculates leg joint angles based on a provided cartesian foot position of a desired foot position. An object should be created for each leg so that all legs can be positioned individually. Important things to note: Calculations assume that provided cartesian coordinates are relative to the quadruped's horizontal position If the quadruped is not horizontal i.e. tilted, you must take account for that and compute adjustments relative to it All units are in millimeters Negative Y-coordinates specify a position towards the quadruped This class only supports legs with 3 degrees of freedom. It is assumed that each leg has 3 motors to control each joint. Foot Coordinate Axis Leg Numbering","title":"Description"},{"location":"Kinematics-library/#functions","text":"","title":"Functions"},{"location":"Kinematics-library/#kinematics","text":"Kinematics :: Kinematics (); Constructor. Create an instance of a Kinematics class as such: Kinematics LegKinematics ();","title":"Kinematics()"},{"location":"Kinematics-library/#init","text":"void Kinematics :: init ( LegID legID , int16_t inputX , int16_t inputY , int16_t inputZ , Motor legMotors []) legID - The leg that the Kinematics object is controlling. Should be of type LegID inputX - The initial (startup) X position that the foot should go to. inputY - The initial (startup) Y position that the foot should go to. inputZ - The initial (startup) Z position that the foot should go to. legMotors[] - An array of length 12 (3 motors per leg, 4 legs) whose variables are of struct type Motor . Note that inputX, inputY, and inputZ are integrated into the Quadruped and StepPlanner classes and serve as origin foot positions there.","title":"init()"},{"location":"Kinematics-library/#enums","text":"","title":"Enums"},{"location":"Kinematics-library/#legid","text":"An enum to describe each leg. typedef enum { LEG_1 = 1 , LEG_2 , LEG_3 , LEG_4 } LegID ;","title":"LegID"},{"location":"Kinematics-library/#structs","text":"","title":"Structs"},{"location":"Kinematics-library/#motor","text":"A struct that holds variables describing motor parameters. typedef struct { uint8_t controlPin ; // Angle/calculation stuff int16_t angleDegrees ; int16_t previousDegrees ; // previous degrees since last call to updateDynamicPositions() int16_t dynamicDegrees ; // Calibration uint16_t calibOffset ; // This is an offset for calibration (to keep the motor accurate) uint16_t maxPos ; uint16_t minPos ; uint16_t applicationOffset ; // This is an offset for putting the calculated angles in contex. // It is likely that the zero positions of the motors isn't where // calculations assumes it to be, so you need an offset to make // sure that the angle is correct relative to the motor's zero. } Motor ;","title":"Motor"}]}